# Enable debug mode if SSH_DEBUG is set
debug() {
    if [ -n "$SSH_DEBUG" ]; then
        echo "DEBUG: $1" >&2
    fi
}

# Initial debug test
debug "bash_ssh script starting up"
debug "SSH_DEBUG=${SSH_DEBUG:-not set}"
debug "Current shell: $SHELL"

# Try to find and set up the SSH agent socket
find_ssh_agent() {
    debug "Starting find_ssh_agent"
    debug "Current SSH_AUTH_SOCK: $SSH_AUTH_SOCK"
    
    # VS Code specific check - if we're in VS Code integrated terminal
    if [ -n "$VSCODE_IPC_HOOK_CLI" ]; then
        debug "Running in VS Code integrated terminal"
        # Try to get SSH_AUTH_SOCK from parent tmux session if we're in one
        if [ -n "$TMUX" ]; then
            debug "Inside tmux session"
            local tmux_ssh_sock=$(tmux show-environment | grep "^SSH_AUTH_SOCK=" | cut -d = -f 2)
            if [ -n "$tmux_ssh_sock" ] && [ -S "$tmux_ssh_sock" ]; then
                debug "Found working tmux SSH socket: $tmux_ssh_sock"
                echo "$tmux_ssh_sock"
                return 0
            fi
            debug "No working tmux SSH socket found"
        fi
    fi

    # Check common socket locations
    local socket_locations=(
        "$SSH_AUTH_SOCK"                          # Current SSH_AUTH_SOCK
        "/tmp/ssh-*/agent.*"                      # Common SSH agent socket pattern
        "$HOME/.vscode-server/bin/*/alpine-*/ssh-*agent.sock" # VS Code remote SSH agent
        "$XDG_RUNTIME_DIR/ssh-agent.socket"       # systemd user socket
        "/var/run/ssh-agent.socket"               # Some RHEL/AlmaLinux locations
        "/run/user/$UID/keyring/ssh"              # GNOME keyring SSH agent socket
    )
    debug "Checking socket locations: ${socket_locations[*]}"

    # First try the explicitly set SSH_AUTH_SOCK if it exists
    if [ -n "$SSH_AUTH_SOCK" ] && [ -S "$SSH_AUTH_SOCK" ]; then
        debug "Testing current SSH_AUTH_SOCK: $SSH_AUTH_SOCK"
        SSH_AUTH_SOCK="$SSH_AUTH_SOCK" ssh-add -l >/dev/null 2>&1
        if [ $? -ne 2 ]; then
            debug "Current SSH_AUTH_SOCK is working"
            echo "$SSH_AUTH_SOCK"
            return 0
        else
            debug "Current SSH_AUTH_SOCK exists but is not working"
        fi
    fi

    # Then try to find other potential sockets
    for socket in "${socket_locations[@]}"; do
        # Use find to expand globs and check for socket files
        while IFS= read -r sock; do
            if [ -S "$sock" ] && [ -r "$sock" ]; then  # Check if socket exists and is readable
                debug "Testing socket: $sock"
                # Test if the socket is actually working
                SSH_AUTH_SOCK="$sock" ssh-add -l >/dev/null 2>&1
                if [ $? -ne 2 ]; then  # Return code 2 means definitely not working
                    debug "Found working socket: $sock"
                    echo "$sock"
                    return 0
                fi
            fi
        done < <(find ${socket%/*} -path "$socket" -type s 2>/dev/null || true)
    done

    # If no working socket found, check if we need to start ssh-agent
    if ! pgrep ssh-agent >/dev/null; then
        debug "No ssh-agent running, starting new one"
        eval $(ssh-agent -s) >/dev/null
        echo "$SSH_AUTH_SOCK"
        return 0
    fi

    return 1
}

# Set up SSH agent socket
setup_ssh_agent() {
    debug "Starting setup_ssh_agent"
    
    # If we're in an SSH session with agent forwarding enabled
    if [ -n "$SSH_CONNECTION" ] && [ -n "$SSH_AUTH_SOCK" ]; then
        debug "SSH connection detected with auth sock: $SSH_AUTH_SOCK"
        # Resolve the real path of SSH_AUTH_SOCK to avoid symlink loops
        real_auth_sock=$(readlink -f "$SSH_AUTH_SOCK" 2>/dev/null || echo "$SSH_AUTH_SOCK")
        debug "Resolved real socket path: $real_auth_sock"
        
        # Test if the socket is actually working
        if [ -S "$real_auth_sock" ]; then
            SSH_AUTH_SOCK="$real_auth_sock" ssh-add -l >/dev/null 2>&1
            if [ $? -ne 2 ]; then
                debug "SSH forwarded socket is working"
                export SSH_AUTH_SOCK="$real_auth_sock"
                debug "Using SSH_AUTH_SOCK=$SSH_AUTH_SOCK directly"
                return 0
            fi
        fi
    fi
    
    # If forwarded socket isn't working or we're not in an SSH session,
    # try to find a working local socket
    if found_socket=$(find_ssh_agent); then
        debug "Found working socket: $found_socket"
        # Resolve the real path to avoid symlink loops
        real_socket=$(readlink -f "$found_socket" 2>/dev/null || echo "$found_socket")
        debug "Resolved real socket path: $real_socket"
        
        if [ -S "$real_socket" ]; then
            export SSH_AUTH_SOCK="$real_socket"
            debug "Using SSH_AUTH_SOCK=$SSH_AUTH_SOCK directly"
            return 0
        fi
    fi
    
    # If no working socket found, start a new agent
    debug "No working socket found, starting new ssh-agent"
    eval $(ssh-agent -s) >/dev/null
    export SSH_AUTH_SOCK
    debug "New SSH_AUTH_SOCK: $SSH_AUTH_SOCK"
    return 0
}

# Enable debug logging if requested
if [ -n "$SSH_DEBUG" ]; then
    debug "Running setup_ssh_agent with debugging enabled"
else
    debug "Running setup_ssh_agent (debugging disabled)"
fi

# Run the setup
setup_ssh_agent
